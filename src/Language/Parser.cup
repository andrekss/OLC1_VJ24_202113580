// ------------  Paquete e importaciones ------------
package Language;
// Importaciones
import java.util.LinkedList;
import Interpreter.Expresiones.*;
import Interpreter.Instrucciones.*;
import Interpreter.Funciones.*;
import Interpreter.Instruccion;
import Interpreter.Expresion;
import client.Errors;
import client.TextEditor;

import java_cup.runtime.*;


//------> Codigo para el parser
//------> Declaracion de variables, funciones y funciones de error

parser code 
{:
    public LinkedList<Instruccion> Ejecutar;
    public LinkedList<LinkedList<Instruccion>> CasesList =  new LinkedList<>();
    public LinkedList<Expresion> Caso =  new LinkedList<>();
    
    public String resultado = ""; 


    public void syntax_error(Symbol s)
    {
            System.err.println("Error Sintactico: "+ s.value + " - Fila: " + s.right + " - Columna: " + s.left + ". Recuperado" );
            Errors error = new Errors("Sintáctico","Se esperaba este "+s.value,s.right, s.left);
            TextEditor.Errores.add(error);

            TextEditor.Print+="Error Sintactico: "+ s.value + " - Fila: " + s.right + " - Columna: " + s.left + ". Recuperado"+"\n";
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {
            System.err.println("Error Sintactico: "+ s.value + " - Fila: " + s.right + " - Columna: " + s.left + ". Sin recuperacion." );
            Errors error = new Errors("Sintáctico","Se esperaba este "+ s.value,s.right, s.left);
            TextEditor.Errores.add(error);
            TextEditor.Print+="Error Sintactico: "+ s.value + " - Fila: " + s.right + " - Columna: " + s.left + ". Sin recuperacion."+"\n";
    }

:}


//------> Codigo para las acciones gramaticales (no tocar)
action code
{:  :}



//------> Declaración de terminales
terminal String INT, DOUBLE, BOOL, CHAR, STRING;
terminal String MAS, MENOS, POR, DIVISION, POTENCIA, MODULO;
terminal String COMPARACION, DIFERENCIA, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
terminal String NOT, AND, OR, XOR;
terminal String ENTERO, DECIMAL, BOOLEAN, CAR, CAD, VAR, CONST, IDENTIFICADOR, Coma;
terminal String Dos_Puntos, P_Coma, IGUAL, P_ABRE, P_CIERRA, C_ABRE, C_CIERRA, PRINT, LLAVE_A, LLAVE_C, IF, ELSE;
terminal String MATCH, DEFAULT, WHILE, FOR, DO, CONTINUE, RETURN, UMENOS, BREAK;

//------> Declaración de no terminales
non terminal LinkedList<Instruccion> inicio, instrucciones;
non terminal LinkedList<Expresion> Datos_Una_Dimension;
non terminal LinkedList<LinkedList<Expresion>> Datos_Dos_Dimension; 
non terminal String Mutabilidad;
non terminal Sen_Else, Bloque_Else_If, Sen_Else_If, Strcuct_Match, Cases;
non terminal Sen_Return;
non terminal Expresion EXPRESION, Entry_Cases, AccederVectores;
non terminal Instruccion instruccion, Func_Print, Dec_Variables,Dec_Vectores,Variables,Asignar_Valor,Asignar_Valor_Vectores,Incremento_Decremento, Sen_Control, Sen_IF, Sen_While,Sen_Ciclicas;
non terminal Instruccion Sen_Do_While, Sen_For, Sen_Transferencia, Sen_Match, Vectores, Tipo_Incremento;
non terminal String Tipos_Dato, Signos_For;

// Presedencia
precedence left OR;
precedence left AND;
precedence left XOR;
precedence right NOT;
precedence left COMPARACION, DIFERENCIA, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
precedence left MAS, MENOS;
precedence left DIVISION, POR, MODULO;
precedence nonassoc POTENCIA;
precedence right UMENOS;

//------> Definir Simbolo Inicial
start with inicio; 


// ------------>  Producciones  <------------

inicio ::= instrucciones:a {: Ejecutar = a;  :}
;

instrucciones ::= instruccion:a                   {: RESULT = new LinkedList<>(); RESULT.add(a); :}
                | instrucciones:a instruccion:b   {: RESULT = a; RESULT.add(b); :}
;

instruccion ::= Variables:a P_Coma             {: RESULT = a; :}
              | Func_Print:p P_Coma            {: RESULT = p; :}
              | Incremento_Decremento:a P_Coma {: RESULT = a; :}
              | Sen_Control:a                  {: RESULT = a; :}
              | Sen_Ciclicas:a                 {: RESULT = a; :}
              | Sen_Transferencia:a P_Coma     {: RESULT = a; :}
              | Vectores:a P_Coma              {: RESULT = a; :}
;

Sen_Return ::= RETURN
             | RETURN EXPRESION
;

Sen_Transferencia ::= BREAK:a        {: RESULT = new Break(aright, aleft); :}// Usado en ciclos
                    | CONTINUE:a     {: RESULT = new Continue(aright, aleft); :}// Usado en ciclos
                    | Sen_Return     // Usado en ciclos y metodos y para la fase 2
;

// Expresiones
/*
--Casteos--
int a double
double a int
int a char
char a int
char a double
*/

EXPRESION ::= MENOS EXPRESION:e                             {: RESULT = new Negacion("ERROR","ERROR",e,eright, eleft); :} %prec UMENOS              
            | EXPRESION:a MAS EXPRESION:b                   {: RESULT = new Aritmeticas(a,"+",b,aright, aleft); :}
            | EXPRESION:a MENOS EXPRESION:b                 {: RESULT = new Aritmeticas(a,"-",b,aright, aleft); :}
            | EXPRESION:a POR EXPRESION:b                   {: RESULT = new Aritmeticas(a,"*",b,aright, aleft); :}
            | EXPRESION:a DIVISION EXPRESION:b              {: RESULT = new Aritmeticas(a,"/",b,aright, aleft); :}
            | EXPRESION:a POTENCIA EXPRESION:b              {: RESULT = new Aritmeticas(a,"**",b,aright, aleft); :}
            | EXPRESION:a MODULO EXPRESION:b                {: RESULT = new Aritmeticas(a,"%",b,aright, aleft); :}
            | P_ABRE EXPRESION:e P_CIERRA                   {: RESULT = e;/*e.interpretar(null); RESULT=new Dato(e.getValor(),e.getTipo(), eright, eleft);*/ :}
            | ENTERO:e                                      {: RESULT=new Dato(e,"INT", eright, eleft); :}
            | DECIMAL:e                                     {: RESULT=new Dato(e,"DOUBLE", eright, eleft); :}
            | BOOLEAN:e                                     {: RESULT=new Dato(e,"BOOL", eright, eleft); :}
            | CAR:e                                         {: RESULT=new Dato(e,"CHAR", eright, eleft); :}
            | CAD:e                                         {: RESULT=new Dato(e,"STRING", eright, eleft); :}
            | P_ABRE Tipos_Dato:tipo P_CIERRA EXPRESION:e   {: RESULT = e; /*e.interpretar(null); RESULT = new Dato(e.getValor(),tipo, eright, eleft);*/ :} // Casteos
            | IDENTIFICADOR:id                              {: RESULT = new AccederVariables(id,idright, idleft); :}
            | AccederVectores:a                             {: RESULT=a; :}
            | EXPRESION:a COMPARACION EXPRESION:b           {: RESULT = new Relacionales(a,"==",b,aright, aleft); :}
            | EXPRESION:a DIFERENCIA EXPRESION:b            {: RESULT = new Relacionales(a,"!=",b,aright, aleft); :}     
            | EXPRESION:a MENOR_IGUAL EXPRESION:b           {: RESULT = new Relacionales(a,"<=",b,aright, aleft); :} 
            | EXPRESION:a MAYOR_IGUAL EXPRESION:b           {: RESULT = new Relacionales(a,">=",b,aright, aleft); :} 
            | EXPRESION:a MENOR EXPRESION:b                 {: RESULT = new Relacionales(a,"<",b,aright, aleft); :} 
            | EXPRESION:a MAYOR EXPRESION:b                 {: RESULT = new Relacionales(a,">",b,aright, aleft); :} 
            | NOT EXPRESION:e                               {: RESULT = new Not("true","BOOL",e,eright, eleft); :}
            | EXPRESION:a AND EXPRESION:b                   {: RESULT = new Logicas(a,"&&",b,aright, aleft); :}
            | EXPRESION:a OR EXPRESION:b                    {: RESULT = new Logicas(a,"||",b,aright, aleft); :}
            | EXPRESION:a XOR EXPRESION:b                   {: RESULT = new Logicas(a,"^",b,aright, aleft); :}
;

// Variables

Tipos_Dato ::= INT    {: RESULT="INT"; :}
             | DOUBLE {: RESULT="DOUBLE"; :}
             | BOOL   {: RESULT="BOOL"; :}
             | CHAR   {: RESULT="CHAR"; :} 
             | STRING {: RESULT="STRING"; :}
;

Mutabilidad ::= VAR     {: RESULT = "VAR"; :}
              | CONST   {: RESULT = "CONST"; :}
;

Variables ::= Dec_Variables:a   {: RESULT = a; :}
            | Asignar_Valor:a   {: RESULT = a; :}
;

Dec_Variables ::= Mutabilidad:m IDENTIFICADOR:id Dos_Puntos Tipos_Dato:ty                        {: RESULT= new Declarar(null,ty,id,m,tyright, tyleft); :}   
                | Mutabilidad:m IDENTIFICADOR:id Dos_Puntos Tipos_Dato:ty IGUAL EXPRESION:e      {: RESULT= new Declarar(e,ty,id,m,tyright, tyleft); :}
;

Asignar_Valor ::= IDENTIFICADOR:i IGUAL EXPRESION:e  {: RESULT = new Asignar(e,i,iright, ileft); :}
;

// Función print
Func_Print ::= PRINT P_ABRE EXPRESION:a P_CIERRA {: RESULT =new Print(a,aright, aleft); :}
;

// Incremento y decremento (Solo para decimales y enteros)
Incremento_Decremento ::= IDENTIFICADOR:id MAS MAS         {: RESULT = new IncrementoDecremento(id,"++",idright, idleft); :}
                        | IDENTIFICADOR:id MENOS MENOS     {: RESULT = new IncrementoDecremento(id,"--",idright, idleft); :}
;

// Sentencias de control
Sen_Control ::= Sen_IF:a     {: RESULT =a; :}
              | Sen_Match:a  {: RESULT=a; :}
;

// Sentencia if

Sen_IF ::= IF P_ABRE EXPRESION:e P_CIERRA LLAVE_A instrucciones:i LLAVE_C ELSE LLAVE_A instrucciones:i2 LLAVE_C     {: RESULT= new IF(e,i,i2,null,eright,eleft); :}
	 | IF P_ABRE EXPRESION:e P_CIERRA LLAVE_A instrucciones:i LLAVE_C ELSE Sen_IF:i2                            {: RESULT= new IF(e,i,null,i2,eright,eleft); :}
         | IF P_ABRE EXPRESION:e P_CIERRA LLAVE_A instrucciones:i LLAVE_C                                           {: RESULT= new IF(e,i,null,null,eright,eleft); :}                      
; 

// Sentencia Match

Entry_Cases ::= EXPRESION:a   {: RESULT=a; :}
	      | DEFAULT:a     {: RESULT=new Dato(a,"STRING", aright, aleft); :}// Este solo irá al final y solo uno
;

Cases ::= Entry_Cases:a IGUAL MAYOR LLAVE_A instrucciones:i LLAVE_C  {: CasesList.add(i); Caso.add(a);  :}   // uso de break
;

Strcuct_Match ::= Cases
	      | Strcuct_Match Cases
;

Sen_Match ::= MATCH EXPRESION:e LLAVE_A Strcuct_Match  LLAVE_C  {: RESULT = new Match(CasesList, Caso, e, eright, eleft);  :}
;


// Sentencias Cíclicas

// todas pueden llevar Break, continue y return
Sen_Ciclicas ::=  Sen_While:a           {: RESULT =a; :}
		| Sen_For:a             {: RESULT = a; :}
		| Sen_Do_While:a P_Coma {: RESULT =a; :}
;


Sen_While ::= WHILE P_ABRE EXPRESION:c P_CIERRA LLAVE_A instrucciones:i LLAVE_C   {: RESULT = new While(c,i,"While",cright, cleft); :}
;


Tipo_Incremento ::= Incremento_Decremento:a {: RESULT=a; :}
                  | Asignar_Valor:a         {: RESULT=a; :}
;

Sen_For ::= FOR P_ABRE Asignar_Valor:a P_Coma EXPRESION:e P_Coma Tipo_Incremento:in  P_CIERRA LLAVE_A instrucciones:i LLAVE_C
{: RESULT = new For(i,a,e,in,iright, ileft); :}
;

Sen_Do_While ::= DO LLAVE_A instrucciones:i LLAVE_C WHILE P_ABRE EXPRESION:c P_CIERRA  {: RESULT = new While(c,i,"Do",cright, cleft); :}
;

// Vectores
Datos_Una_Dimension ::= EXPRESION:a                               {: RESULT = new LinkedList<>(); RESULT.add(a); :}
                      | Datos_Una_Dimension:a Coma EXPRESION:b    {: RESULT = a; RESULT.add(b); :}
;

Datos_Dos_Dimension ::= C_ABRE Datos_Una_Dimension:a C_CIERRA                             {: RESULT = new LinkedList<>(); RESULT.add(a); :}
                      | Datos_Dos_Dimension:a Coma C_ABRE Datos_Una_Dimension:b C_CIERRA  {: RESULT = a; RESULT.add(b); :}
;

Dec_Vectores ::= Mutabilidad:m IDENTIFICADOR:i Dos_Puntos Tipos_Dato:t C_ABRE C_CIERRA IGUAL C_ABRE Datos_Una_Dimension:v1 C_CIERRA {: RESULT = new Vectores(v1,null,t,i,m,iright, ileft); :}
               | Mutabilidad:m IDENTIFICADOR:i Dos_Puntos Tipos_Dato:t C_ABRE C_CIERRA C_ABRE C_CIERRA IGUAL C_ABRE Datos_Dos_Dimension:v2 C_CIERRA {: RESULT = new Vectores(null,v2,t,i,m,iright, ileft); :}
;

Asignar_Valor_Vectores ::= IDENTIFICADOR:i C_ABRE EXPRESION:x C_CIERRA IGUAL EXPRESION:e                               {: RESULT = new Asignar_Vectores(e,i,x,x,"Vector1",iright, ileft); :}
                        |  IDENTIFICADOR:i C_ABRE EXPRESION:x C_CIERRA C_ABRE EXPRESION:y C_CIERRA IGUAL EXPRESION:e   {: RESULT = new Asignar_Vectores(e,i,x,y,"Vector2",iright, ileft); :}
;

Vectores ::= Dec_Vectores:a              {: RESULT = a; :}
           | Asignar_Valor_Vectores:a    {: RESULT = a; :}
;

// Acceso Vectores

AccederVectores ::= IDENTIFICADOR:i C_ABRE EXPRESION:x C_CIERRA                              {: RESULT = new AccederVectores(i,x,x,"Vector1",iright, ileft); :}  // una dimensión
                  | IDENTIFICADOR:i C_ABRE EXPRESION:x C_CIERRA C_ABRE EXPRESION:y C_CIERRA  {: RESULT = new AccederVectores(i,x,y,"Vector2",iright, ileft); :}// dos dimensiones
;

