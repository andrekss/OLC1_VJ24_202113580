// ------------  Paquete e importaciones ------------
package Language;
// Importaciones
import java.util.LinkedList;
import Interpreter.Expresiones.*;
import Interpreter.Instrucciones.*;
import Interpreter.Funciones.*;
import Interpreter.Instruccion;
import Interpreter.Expresion;
import client.Errors;
import client.TextEditor;
import Interpreter.Entornos.*;

import java_cup.runtime.*;


//------> Codigo para el parser
//------> Declaracion de variables, funciones y funciones de error

parser code 
{:
    public LinkedList<Instruccion> Ejecutar;
    public LinkedList<LinkedList<Instruccion>> CasesList =  new LinkedList<>();
    public LinkedList<Expresion> Caso =  new LinkedList<>();
    
    public String resultado = ""; 


    public void syntax_error(Symbol s)
    {
            System.err.println("Error Sintactico: "+ s.value + " - Fila: " + s.right + " - Columna: " + s.left + ". Recuperado" );
            Errors error = new Errors("Sintáctico","Se esperaba este "+s.value,s.right, s.left);
            TextEditor.Errores.add(error);

            TextEditor.Print+="Error Sintactico: "+ s.value + " - Fila: " + s.right + " - Columna: " + s.left + ". Recuperado"+"\n";
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {
            System.err.println("Error Sintactico: "+ s.value + " - Fila: " + s.right + " - Columna: " + s.left + ". Sin recuperacion." );
            Errors error = new Errors("Sintáctico","Se esperaba este "+ s.value,s.right, s.left);
            TextEditor.Errores.add(error);
            TextEditor.Print+="Error Sintactico: "+ s.value + " - Fila: " + s.right + " - Columna: " + s.left + ". Sin recuperacion."+"\n";
    }

:}


//------> Codigo para las acciones gramaticales (no tocar)
action code
{:  :}



//------> Declaración de terminales
terminal String INT, DOUBLE, BOOL, CHAR, STRING, VOID;
terminal String MAS, MENOS, POR, DIVISION, POTENCIA, MODULO;
terminal String COMPARACION, DIFERENCIA, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL,  REMOVE, START;
terminal String NOT, AND, OR, XOR;
terminal String ENTERO, DECIMAL, BOOLEAN, CAR, CAD, VAR, CONST, IDENTIFICADOR, Coma;
terminal String Dos_Puntos, P_Coma, IGUAL, P_ABRE, P_CIERRA, C_ABRE, C_CIERRA, PRINT, LLAVE_A, LLAVE_C, IF, ELSE;
terminal String MATCH, DEFAULT, WHILE, FOR, DO, CONTINUE, RETURN, UMENOS, BREAK, LIST, NEW, APPEND, Punto, STRUCT;

//------> Declaración de no terminales
non terminal LinkedList<Instruccion> inicio, instrucciones;
non terminal LinkedList<Expresion> Datos_Una_Dimension;
non terminal LinkedList<LinkedList<Expresion>> Datos_Dos_Dimension; 
non terminal String Mutabilidad;
non terminal Sen_Else, Bloque_Else_If, Sen_Else_If, Strcuct_Match, Cases;
non terminal Sen_Return ;
non terminal Expresion EXPRESION, Entry_Cases, AccederVectores, Remove_Valores_Listas;
non terminal Instruccion instruccion, Func_Print, Dec_Variables,Dec_Vectores,Variables,Asignar_Valor,Asignar_Valor_Vectores,Incremento_Decremento, Sen_Control, Sen_IF, Sen_While,Sen_Ciclicas;
non terminal Instruccion Sen_Do_While, Sen_For, Sen_Transferencia, Sen_Match, Vectores, Tipo_Incremento, Listas, Declaracion_Listas, Agregar_Lista, Structs, Dec_Structs;
non terminal Instruccion Instancia_Struct, Asignar_Struct, Funciones, Métodos, Start_With, Llamadas;
non terminal String Tipos_Dato, Signos_For;
non terminal LinkedList<Atributo> Lista_Structs;
non terminal LinkedList<Def_Atributo> Nombre_Struct;
non terminal LinkedList<Atributo>  Parámetros;

// Presedencia
precedence left OR;
precedence left AND;
precedence left XOR;
precedence right NOT;
precedence left COMPARACION, DIFERENCIA, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
precedence left MAS, MENOS;
precedence left DIVISION, POR, MODULO;
precedence nonassoc POTENCIA;
precedence right UMENOS;

//------> Definir Simbolo Inicial
start with inicio; 


// ------------>  Producciones  <------------

inicio ::= instrucciones:a {: Ejecutar = a;  :}
;

instrucciones ::= instruccion:a                   {: RESULT = new LinkedList<>(); RESULT.add(a); :}
                | instrucciones:a instruccion:b   {: RESULT = a; RESULT.add(b); :}
;

instruccion ::= Variables:a P_Coma             {: RESULT = a; :}
              | Func_Print:p P_Coma            {: RESULT = p; :}
              | Incremento_Decremento:a P_Coma {: RESULT = a; :}
              | Sen_Control:a                  {: RESULT = a; :}
              | Sen_Ciclicas:a                 {: RESULT = a; :}
              | Sen_Transferencia:a P_Coma     {: RESULT = a; :}
              | Vectores:a P_Coma              {: RESULT = a; :}
              | Listas:a P_Coma                {: RESULT = a; :}
              | Structs:a P_Coma               {: RESULT = a; :}
              | Métodos:a                      {: RESULT = a; :}
              | Llamadas:a P_Coma              {: RESULT = a; :}
              | Start_With:a P_Coma            {: RESULT = a; :}
;

Sen_Return ::= RETURN
             | RETURN EXPRESION
;

Sen_Transferencia ::= BREAK:a        {: RESULT = new Break(aright, aleft); :}// Usado en ciclos
                    | CONTINUE:a     {: RESULT = new Continue(aright, aleft); :}// Usado en ciclos
                    | Sen_Return     // Usado en ciclos y metodos y para la fase 2
;

// Expresiones
/*
--Casteos--
int a double
double a int
int a char
char a int
char a double
*/

EXPRESION ::= MENOS EXPRESION:e                             {: RESULT = new Negacion("ERROR","ERROR",e,eright, eleft); :} %prec UMENOS              
            | EXPRESION:a MAS EXPRESION:b                   {: RESULT = new Aritmeticas(a,"+",b,aright, aleft); :}
            | EXPRESION:a MENOS EXPRESION:b                 {: RESULT = new Aritmeticas(a,"-",b,aright, aleft); :}
            | EXPRESION:a POR EXPRESION:b                   {: RESULT = new Aritmeticas(a,"*",b,aright, aleft); :}
            | EXPRESION:a DIVISION EXPRESION:b              {: RESULT = new Aritmeticas(a,"/",b,aright, aleft); :}
            | EXPRESION:a POTENCIA EXPRESION:b              {: RESULT = new Aritmeticas(a,"**",b,aright, aleft); :}
            | EXPRESION:a MODULO EXPRESION:b                {: RESULT = new Aritmeticas(a,"%",b,aright, aleft); :}
            | P_ABRE EXPRESION:e P_CIERRA                   {: RESULT = e;/*e.interpretar(null); RESULT=new Dato(e.getValor(),e.getTipo(), eright, eleft);*/ :}
            | ENTERO:e                                      {: RESULT=new Dato(e,"INT", eright, eleft); :}
            | DECIMAL:e                                     {: RESULT=new Dato(e,"DOUBLE", eright, eleft); :}
            | BOOLEAN:e                                     {: RESULT=new Dato(e,"BOOL", eright, eleft); :}
            | CAR:e                                         {: RESULT=new Dato(e,"CHAR", eright, eleft); :}
            | CAD:e                                         {: RESULT=new Dato(e,"STRING", eright, eleft); :}
            | P_ABRE Tipos_Dato:tipo P_CIERRA EXPRESION:e   {: RESULT = new Casteo(tipo,e,eright, eleft);  :} // Casteos
            | IDENTIFICADOR:id                              {: RESULT = new AccederVariables(id,idright, idleft); :}
            | AccederVectores:a                             {: RESULT=a; :}
            | EXPRESION:a COMPARACION EXPRESION:b           {: RESULT = new Relacionales(a,"==",b,aright, aleft); :}
            | EXPRESION:a DIFERENCIA EXPRESION:b            {: RESULT = new Relacionales(a,"!=",b,aright, aleft); :}     
            | EXPRESION:a MENOR_IGUAL EXPRESION:b           {: RESULT = new Relacionales(a,"<=",b,aright, aleft); :} 
            | EXPRESION:a MAYOR_IGUAL EXPRESION:b           {: RESULT = new Relacionales(a,">=",b,aright, aleft); :} 
            | EXPRESION:a MENOR EXPRESION:b                 {: RESULT = new Relacionales(a,"<",b,aright, aleft); :} 
            | EXPRESION:a MAYOR EXPRESION:b                 {: RESULT = new Relacionales(a,">",b,aright, aleft); :} 
            | NOT EXPRESION:e                               {: RESULT = new Not("true","BOOL",e,eright, eleft); :}
            | EXPRESION:a AND EXPRESION:b                   {: RESULT = new Logicas(a,"&&",b,aright, aleft); :}
            | EXPRESION:a OR EXPRESION:b                    {: RESULT = new Logicas(a,"||",b,aright, aleft); :}
            | EXPRESION:a XOR EXPRESION:b                   {: RESULT = new Logicas(a,"^",b,aright, aleft); :}
            | Remove_Valores_Listas:a                       {: RESULT = a; :}
            | IDENTIFICADOR:id Punto IDENTIFICADOR:att      {:  RESULT = new AccederStruct(id,att,idright, idleft); :}
;

// Variables

Tipos_Dato ::= INT    {: RESULT="INT"; :}
             | DOUBLE {: RESULT="DOUBLE"; :}
             | BOOL   {: RESULT="BOOL"; :}
             | CHAR   {: RESULT="CHAR"; :} 
             | STRING {: RESULT="STRING"; :}
;

Mutabilidad ::= VAR     {: RESULT = "VAR"; :}
              | CONST   {: RESULT = "CONST"; :}
;

Variables ::= Dec_Variables:a   {: RESULT = a; :}
            | Asignar_Valor:a   {: RESULT = a; :}
;

Dec_Variables ::= Mutabilidad:m IDENTIFICADOR:id Dos_Puntos Tipos_Dato:ty                        {: RESULT= new Declarar(null,ty,id,m,tyright, tyleft); :}   
                | Mutabilidad:m IDENTIFICADOR:id Dos_Puntos Tipos_Dato:ty IGUAL EXPRESION:e      {: RESULT= new Declarar(e,ty,id,m,tyright, tyleft); :}
;

Asignar_Valor ::= IDENTIFICADOR:i IGUAL EXPRESION:e  {: RESULT = new Asignar(e,i,iright, ileft); :}
;

// Función print
Func_Print ::= PRINT P_ABRE EXPRESION:a P_CIERRA {: RESULT =new Print(a,aright, aleft); :}
;

// Incremento y decremento (Solo para decimales y enteros)
Incremento_Decremento ::= IDENTIFICADOR:id MAS MAS         {: RESULT = new IncrementoDecremento(id,"++",idright, idleft); :}
                        | IDENTIFICADOR:id MENOS MENOS     {: RESULT = new IncrementoDecremento(id,"--",idright, idleft); :}
;

// Sentencias de control
Sen_Control ::= Sen_IF:a     {: RESULT =a; :}
              | Sen_Match:a  {: RESULT=a; :}
;

// Sentencia if

Sen_IF ::= IF P_ABRE EXPRESION:e P_CIERRA LLAVE_A instrucciones:i LLAVE_C ELSE LLAVE_A instrucciones:i2 LLAVE_C     {: RESULT= new IF(e,i,i2,null,eright,eleft); :}
	 | IF P_ABRE EXPRESION:e P_CIERRA LLAVE_A instrucciones:i LLAVE_C ELSE Sen_IF:i2                            {: RESULT= new IF(e,i,null,i2,eright,eleft); :}
         | IF P_ABRE EXPRESION:e P_CIERRA LLAVE_A instrucciones:i LLAVE_C                                           {: RESULT= new IF(e,i,null,null,eright,eleft); :}                      
; 

// Sentencia Match

Entry_Cases ::= EXPRESION:a   {: RESULT=a; :}
	      | DEFAULT:a     {: RESULT=new Dato(a,"STRING", aright, aleft); :}// Este solo irá al final y solo uno
;

Cases ::= Entry_Cases:a IGUAL MAYOR LLAVE_A instrucciones:i LLAVE_C  {: CasesList.add(i); Caso.add(a);  :}   // uso de break
;

Strcuct_Match ::= Cases
	      | Strcuct_Match Cases
;

Sen_Match ::= MATCH EXPRESION:e LLAVE_A Strcuct_Match  LLAVE_C  {: RESULT = new Match(CasesList, Caso, e, eright, eleft);  :}
;


// Sentencias Cíclicas

// todas pueden llevar Break, continue y return
Sen_Ciclicas ::=  Sen_While:a           {: RESULT =a; :}
		| Sen_For:a             {: RESULT = a; :}
		| Sen_Do_While:a P_Coma {: RESULT =a; :}
;


Sen_While ::= WHILE P_ABRE EXPRESION:c P_CIERRA LLAVE_A instrucciones:i LLAVE_C   {: RESULT = new While(c,i,"While",cright, cleft); :}
;


Tipo_Incremento ::= Incremento_Decremento:a {: RESULT=a; :}
                  | Asignar_Valor:a         {: RESULT=a; :}
;

Sen_For ::= FOR P_ABRE Asignar_Valor:a P_Coma EXPRESION:e P_Coma Tipo_Incremento:in  P_CIERRA LLAVE_A instrucciones:i LLAVE_C
{: RESULT = new For(i,a,e,in,iright, ileft); :}
;

Sen_Do_While ::= DO LLAVE_A instrucciones:i LLAVE_C WHILE P_ABRE EXPRESION:c P_CIERRA  {: RESULT = new While(c,i,"Do",cright, cleft); :}
;

// Vectores
Datos_Una_Dimension ::= EXPRESION:a                               {: RESULT = new LinkedList<>(); RESULT.add(a); :}
                      | Datos_Una_Dimension:a Coma EXPRESION:b    {: RESULT = a; RESULT.add(b); :}
;

Datos_Dos_Dimension ::= C_ABRE Datos_Una_Dimension:a C_CIERRA                             {: RESULT = new LinkedList<>(); RESULT.add(a); :}
                      | Datos_Dos_Dimension:a Coma C_ABRE Datos_Una_Dimension:b C_CIERRA  {: RESULT = a; RESULT.add(b); :}
;

Dec_Vectores ::= Mutabilidad:m IDENTIFICADOR:i Dos_Puntos Tipos_Dato:t C_ABRE C_CIERRA IGUAL C_ABRE Datos_Una_Dimension:v1 C_CIERRA {: RESULT = new Vectores(v1,null,t,i,m,iright, ileft); :}
               | Mutabilidad:m IDENTIFICADOR:i Dos_Puntos Tipos_Dato:t C_ABRE C_CIERRA C_ABRE C_CIERRA IGUAL C_ABRE Datos_Dos_Dimension:v2 C_CIERRA {: RESULT = new Vectores(null,v2,t,i,m,iright, ileft); :}
;

Asignar_Valor_Vectores ::= IDENTIFICADOR:i C_ABRE EXPRESION:x C_CIERRA IGUAL EXPRESION:e                               {: RESULT = new Asignar_Vectores(e,i,x,x,"Vector1",0,iright, ileft); :}
                        |  IDENTIFICADOR:i C_ABRE EXPRESION:x C_CIERRA C_ABRE EXPRESION:y C_CIERRA IGUAL EXPRESION:e   {: RESULT = new Asignar_Vectores(e,i,x,y,"Vector2",0,iright, ileft); :}
;

Vectores ::= Dec_Vectores:a              {: RESULT = a; :}
           | Asignar_Valor_Vectores:a    {: RESULT = a; :}
;

// Acceso Vectores

AccederVectores ::= IDENTIFICADOR:i C_ABRE EXPRESION:x C_CIERRA                              {: RESULT = new AccederVectList(i,x,x,"Vector1",iright, ileft); :}  // una dimensión
                  | IDENTIFICADOR:i C_ABRE EXPRESION:x C_CIERRA C_ABRE EXPRESION:y C_CIERRA  {: RESULT = new AccederVectList(i,x,y,"Vector2",iright, ileft); :}// dos dimensiones
;


// Listas

Declaracion_Listas ::=LIST MENOR Tipos_Dato:t MAYOR IDENTIFICADOR:i IGUAL NEW LIST P_ABRE P_CIERRA         {: RESULT = new Listas(new LinkedList<>(),t,i,iright, ileft); :}
;

Agregar_Lista ::= IDENTIFICADOR:i Punto APPEND P_ABRE EXPRESION:e P_CIERRA    {: RESULT = new Append(e,i,iright, ileft); :}
;

Remove_Valores_Listas ::= IDENTIFICADOR:id Punto REMOVE P_ABRE EXPRESION:e P_CIERRA {: RESULT = new Remove_Valor(e,id,idright, idleft); :}
;

Listas ::= Declaracion_Listas:a    {: RESULT = a; :}
        |  Agregar_Lista:a         {: RESULT = a; :}
;

// Structs

Lista_Structs ::= IDENTIFICADOR:i Dos_Puntos Tipos_Dato:t P_Coma                   {: RESULT = new LinkedList<>(); RESULT.add(new Atributo(i,t)); :}
                | Lista_Structs:a IDENTIFICADOR:i Dos_Puntos Tipos_Dato:t P_Coma   {: RESULT = a; RESULT.add(new Atributo(i,t)); :}
;

Dec_Structs ::= STRUCT LLAVE_A Lista_Structs:att LLAVE_C IDENTIFICADOR:i  {: RESULT = new Structs(i,att,iright, ileft); :}
;

Nombre_Struct ::=  IDENTIFICADOR:i Dos_Puntos EXPRESION:e                        {: RESULT = new LinkedList<>();  RESULT.add(new Def_Atributo(i,e)); :}
                | Nombre_Struct:a Coma IDENTIFICADOR:i Dos_Puntos EXPRESION:e    {: RESULT = a; RESULT.add(new Def_Atributo(i,e)); :}
;

Instancia_Struct ::= Mutabilidad:m IDENTIFICADOR:id Dos_Puntos IDENTIFICADOR:Ts IGUAL LLAVE_A Nombre_Struct:AD  LLAVE_C {: RESULT = new Instanciar_Struct(m,id,Ts,AD,idright, idleft); :}
;

Asignar_Struct ::= IDENTIFICADOR:i Punto IDENTIFICADOR:att IGUAL EXPRESION:e  {: RESULT = new AsignarStructs(i,att,e,iright, ileft); :}
;

Structs ::= Dec_Structs:a       {: RESULT =a; :}
          | Instancia_Struct:a  {: RESULT =a; :} 
          | Asignar_Struct:a    {: RESULT =a; :}
;

// Declaración de métodos

Parámetros ::= Tipos_Dato:t IDENTIFICADOR:i                                               {: RESULT = new LinkedList<>(); RESULT.add(new Atributo(i,t)); :}
            |  Parámetros:a Coma Tipos_Dato:t IDENTIFICADOR:i                               {: RESULT = a; RESULT.add(new Atributo(i,t)); :}
;

Métodos ::= VOID IDENTIFICADOR:i P_ABRE Parámetros:p P_CIERRA LLAVE_A instrucciones:in LLAVE_C     {: RESULT = new Metodos(i,p,in,iright, ileft);  :}
         |  VOID IDENTIFICADOR:i P_ABRE  P_CIERRA LLAVE_A instrucciones:in LLAVE_C                 {: RESULT = new Metodos(i,new LinkedList<>(),in,iright, ileft);  :}
;

// Función Start with

Start_With ::= START IDENTIFICADOR:id P_ABRE P_CIERRA                         {: RESULT = new Llamadas(new LinkedList<>(),id, idright, idleft); RESULT.setTipo("START_WITH"); :}
             | START IDENTIFICADOR:id P_ABRE Datos_Una_Dimension:dd P_CIERRA  {: RESULT = new Llamadas(dd,id, idright, idleft); RESULT.setTipo("START_WITH"); :}
;

Llamadas ::= IDENTIFICADOR:id P_ABRE P_CIERRA                       {: RESULT = new Llamadas(new LinkedList<>(),id, idright, idleft); :}
          |  IDENTIFICADOR:id P_ABRE Datos_Una_Dimension:dd P_CIERRA   {: RESULT = new Llamadas(dd,id,idright, idleft); :}
;
